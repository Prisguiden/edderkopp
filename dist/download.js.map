{"version":3,"sources":["../src/download.js"],"names":[],"mappings":"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","file":"download.js","sourcesContent":["import request from \"request\";\nimport log from './log';\n\nexport default class Download {\n\n    _timeout = 60000;\n    _delay = 0;\n\n    static get(url, cookies) {\n        if (cookies) {\n            this._jar = request.jar()\n            for (let cookie of cookies) {\n                this._jar.setCookie(cookie, url);\n            }\n        }\n\n        // Get from cache or download it?\n        if (this._cache && this._cache.has(url)) {\n            log.verbose('[download] %s (CACHED) ', url);\n            return Promise.resolve(this._cache.get(url));\n        } else {\n            return (async () => {\n                // Wait between downloads?\n                if (this._delay) {\n                    log.verbose('[download] %s (delay %s s)', url, this._delay.toFixed(1));\n                    await new Promise(resolve => setTimeout(resolve, this._delay * 1000));\n                } else {\n                    log.verbose('[download] %s', url);\n                }\n\n                // Prepare options for request\n                let options = {\n                    url: url,\n                    headers: {\n                        'User-Agent': USER_AGENT\n                    },\n                    gzip: true,\n                    timeout: this._timeout\n                };\n                if (this._jar) {\n                    options.jar = this._jar;\n                }\n                return await this._download(options);\n            })();\n        }\n    }\n\n    static _download(options) {\n        const t0 = process.hrtime();\n        return new Promise((resolve, reject) => {\n            request(options, (error, response, content) => {\n                if (error !== null) {\n                    reject(error);\n                } else if (response.statusCode !== 200) {\n                    reject('Error! Response code: ' + response.statusCode);\n                } else if (content) {\n                    // Use cache?\n                    if (this._cache) {\n                        this._cache.set(options.url, content);\n                    }\n\n                    // Debug info\n                    let diff = process.hrtime(t0);\n                    let time = (diff[0] + diff[1] * 1e-9).toFixed(2) + ' s';\n                    let size = (response.socket.bytesRead / 1024).toFixed(2) + ' KB';\n                    let gzip = response.headers['content-encoding'] == 'gzip';\n                    log.debug('[download] %s (done)', options.url);\n                    log.silly(response.headers);\n                    log.silly('[download] size: %s (%s)', size, gzip ? 'gzip' : 'uncompressed');\n                    log.silly('[download] time: ' + time);\n\n                    resolve(content);\n                } else {\n                    reject('This should not happen');\n                }\n            });\n        });\n\n    }\n\n    static set timeout(t) {\n        this._timeout = t * 1000;\n    }\n\n    // Get cache\n    // Ex: Download.cache.has(url)\n    static get cache() {\n        return this._cache;\n    }\n\n    // Injecting cache\n    static set cache(cache) {\n        this._cache = cache;\n    }\n\n    // Tell Download to wait before proceeding with the actual download\n    static set delay(t) {\n        this._delay = t;\n    }\n}\n"]}