{"version":3,"sources":["../src/parser.js"],"names":[],"mappings":"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","file":"parser.js","sourcesContent":["import cheerio from \"cheerio\";\nimport log from './log';\nimport * as parserTasks from './parser-tasks';\n\n// Parser\nexport default class {\n\n    includeNull = true; // Keep values=null in dataset\n\n    constructor(html) {\n        if (html) {\n            this._load(html);\n        }\n    }\n\n    get html() {\n        return this._html;\n    }\n\n    set html(html) {\n        this._load(html);\n    }\n\n    _load(html) {\n        this._html = html;\n        this._$ = cheerio.load(html);\n    }\n\n    find(selector) {\n        let $ = this._$;\n        return !!$(selector).length\n    }\n\n    getData(rules) {\n        return this._recParse(rules);\n    }\n\n\n    getLinks(link = [ { elem: 'a' } ], skip = []) {\n        let $ = this._$;\n        let links = [];\n\n        // Handle link\n        if (!Array.isArray(link)) {\n            link = [ link ];\n        }\n\n        // Handle skip\n        skip.push('a[rel=nofollow]');\n\n        for (let i = 0; i < link.length; i++) {\n            let f = link[i];\n            // Convert \"shortcut\" for regexp match to proper task\n            // link: [ '<regexp>', .. ]\n            if (typeof f === 'string') {\n                f = { task: [ 'match', f ] };\n            }\n            if (!f.elem) {\n                f.elem = 'a';\n            }\n\n            // Handle skip => add :not(<skip>) to selectors\n            let selector =  f.elem.split(',');\n            for (let j = 0; j < selector.length; j++) {\n                selector[j] += ':not(' + skip.join(',') + ')';\n            }\n            selector = selector.join(',');\n\n            // Find stuff\n            $(selector).each((i, elem) => {\n                let url = $(elem).attr('href').trim();\n                if (url && f.task) {\n                    url = this._runTasks(f.task, url);\n                }\n                if (url) {\n                    links.push(url);\n                }\n            });\n\n        }\n\n        return links;\n    }\n\n    // Recursively parse DOM\n    _recParse(rules, data, $container) {\n        let $ = this._$;\n        data = data || {};\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i];\n            if (rule.name) {\n                // const $elem = rule.elem ? $(rule.elem, $container) : $container;\n                let $elem, optional = false;\n                if (rule.elem) {\n                    if (Array.isArray(rule.elem)) {\n                        $elem = $(rule.elem[0], $container);\n                        optional = rule.elem[1] == 'optional';\n                    } else {\n                        $elem = $(rule.elem, $container);\n                    }\n                } else {\n                    $elem = $container;\n                }\n                if ($elem.length > 0) {\n                    if (rule.data == 'array') {\n                        data[rule.name] = data[rule.name] || [];\n                        $elem.each((i, e) => {\n                            let obj = {};\n                            data[rule.name].push(obj);\n                            this._recParse(rule.kids, obj, $(e));\n                        });\n                    } else if (rule.data == 'object') {\n                        data[rule.name] = {};\n                        this._recParse(rule.kids, data[rule.name], $elem);\n                    } else if (rule.data && rule.data[0] == 'constant') {\n                        data[rule.name] = rule.data[1];\n                    } else {\n                        const values = this._getContent($elem, rule);\n                        if (values !== null || this.includeNull) {\n                            // Join values with same name\n                            data[rule.name] = data[rule.name] ? [].concat(data[rule.name], values) : values;\n                        }\n                    }\n                } else if (!optional) {\n                    log.warn('[parser] Element not found: ' + rule.elem);\n                }\n            } else if (rule.elem) {\n                this._recParse(rule.kids, data, $(rule.elem, $container));\n            }\n        }\n        return data;\n    }\n\n    // Get values\n    _getContent($elem, rule) {\n        let $ = this._$;\n        let value, values = [];\n        const dataType = Array.isArray(rule.data) ? rule.data[0] : rule.data;\n        $elem.each(function() {\n            switch (dataType) {\n                case 'html':\n                    // Get all content including tags\n                    // Ex: <p>paragraph 1</p> <p>paragraph 2</p> <p>paragraph 3</p>\n                    value = $(this).html().trim();\n                    if (value) {\n                        values.push(value);\n                    }\n                    break;\n                case 'text':\n                    // Get only text nodes\n                    // Ex: <span>skip this</span> get this <span>skip this</span>\n                    let nodes = [];\n                    $(this).contents().each((i, el) => {\n                        if (el.nodeType == 3) { // 3 = TEXT_NODE\n                            value = el.data.trim();\n                            if (value) {\n                                nodes.push(el.data.trim());\n                            }\n                        }\n                    });\n                    const index = typeof rule.data !== 'string' ? rule.data[1] : false;\n                    if (index !== false) {\n                        values.push(nodes[index]);\n                    } else {\n                        values = [].concat(values, nodes);\n                    }\n                    break;\n                case 'attr':\n                    // Get content from attribute\n                    // Ex: <img src=\"value\">, <a href=\"value\">foo</a>\n                    for (let i = 1; i < rule.data.length; i++) {\n                        value = $(this).attr(rule.data[i]);\n                        if (value) {\n                            values.push(value);\n                        } else {\n                            log.warn('[parser] Attribute not found: ' + rule.data[i]);\n                        }\n                    }\n                    break;\n                case 'data':\n                    // Get content from data\n                    // Ex: <div data-img-a=\"value\" data-img-b=\"value\" data-img-c=\"value\">\n                    for (let i = 1; i < rule.data.length; i++) {\n                        value = $(this).data(rule.data[i]);\n                        if (value) {\n                            values.push(value);\n                        } else {\n                            log.warn('[parser] Data attribute not found: ' + rule.data[i]);\n                        }\n                    }\n                    break;\n                default:\n                    // Get only text (strip away tags)\n                    value = $(this).text().trim();\n                    if (value) {\n                        values.push(value);\n                    }\n            }\n        });\n\n        // Run tasks on values\n        if (rule.task && values.length) {\n            values = this._runTasks(rule.task, values);\n        }\n\n        // No need to wrap single/empty values in an array\n        if (values.length <= 1) {\n            values = values.length == 1 ? values.pop() : null;\n        }\n\n        return values;\n    }\n\n    _runTasks(tasks, values) {\n        // Code handles multiple values\n        if (typeof values == 'string') {\n            values = [ values ];\n        }\n\n        // Rewrite different task formats to:\n        // \"task\": [\n        //     [ \"foobar1\", \"arg1a\", \"arg1b\" ],\n        //     [ \"foobar2\", \"arg2a\", \"arg2b\" ]\n        //  ]\n        if (typeof tasks == 'string') { // \"task\": \"foobar\"\n            tasks = [ [ tasks ] ];\n        } else if (!Array.isArray(tasks[0])) { // \"task\": [ \"foobar\", \"arg1\", \"arg2\" ]\n            tasks = [ tasks ];\n        }\n\n        // Run tasks and pipe result from one to the next\n        for (let task of tasks) {\n            let name = task[0];\n            if (parserTasks[name]) {\n                let args = task.slice(1);\n                let tmp = [];\n                for (let value of values) {\n                    let res = parserTasks[name](args, value);\n                    if (res) {\n                        tmp = tmp.concat(res);\n                    }\n                }\n                values = tmp;\n                if (!values.length) {\n                    break;\n                }\n            } else {\n                log.warn('[parser] Task doesn\\'t exist: ' + name);\n            }\n        }\n        if (values.length <= 1) {\n            values = values.length == 1 ? values.pop() : null;\n        }\n        return values;\n    }\n\n    // Support custom tasks\n    static injectTasks(customTasks) {\n        for (var prop in customTasks) {\n            if (parserTasks[prop]) {\n                log.warn('[parser] Overriding task: ' + prop);\n            }\n            parserTasks[prop] = customTasks[prop];\n        }\n    }\n}\n"]}